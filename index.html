<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Galerie — Consultation uniquement</title>
<style>
  :root { --gap: 12px; }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#111; color:#eee; }
  body.modal-open { overflow: hidden; } /* bloque le scroll du fond */

  header { padding:14px 16px; text-align:center; font-weight:600; }

  /* Grille responsive */
  .grid {
    display:grid; gap:var(--gap);
    grid-template-columns: 1fr;               /* mobile par défaut */
    padding: var(--gap);
    max-width: 1200px; margin: 0 auto;
  }
  @media (min-width: 600px) { .grid { grid-template-columns: repeat(2, 1fr); } }
  @media (min-width: 1024px) {
    body { display: grid; grid-template-rows: auto 1fr; }
    header { padding: 10px 16px; }
    .grid {
      max-width: none; margin: 0;
      grid-template-columns: repeat(2, 1fr);
      grid-template-rows: repeat(2, 1fr);
      height: calc(100vh - 56px);             /* plein écran sous le header */
    }
  }

  /* Cartes + miniatures entières (contain) */
  .card {
    background:#1a1a1a; border-radius:16px; overflow:hidden;
    box-shadow: 0 6px 20px rgba(0,0,0,.35);
    display: grid; grid-template-rows: 1fr auto;
  }
  .thumb {
    width:100%;
    aspect-ratio: 3 / 4;
    background: #222 center/contain no-repeat; /* montre l’image entière */
    user-select:none; -webkit-user-drag: none;
  }
  @media (min-width: 1024px){
    .thumb { aspect-ratio: auto; height: 100%; }
  }
  .cap { padding:10px 12px; font-size:14px; opacity:.85; background: rgba(255,255,255,.04); }

  /* Dissuasion téléchargement */
  html { -webkit-touch-callout: none; }
  img { -webkit-user-drag: none; }

  /* Visionneuse */
  .lightbox {
    position: fixed; inset:0; display:none; place-items:center;
    background: rgba(0,0,0,.9); z-index: 9999;
  }
  .lightbox.open { display:grid; }
  .stage {
    width: min(92vw, 1400px); height: min(92vh, 90vw);
    background: #000;
    position: relative; overflow: hidden;
    touch-action: none;                        /* pour pinch/pan */
    border-radius: 12px;
  }
  .stage img {
    position: absolute; left: 50%; top: 50%;
    max-width: none; max-height: none;         /* géré via transform */
    transform: translate(-50%, -50%) scale(1);
    transform-origin: center center;
    cursor: grab; user-select: none; will-change: transform;
    pointer-events: auto;
  }
  .stage img.grabbing { cursor: grabbing; }

  .ui {
    position: absolute; inset:auto 0 0 0; display:flex; gap:8px;
    justify-content: center; padding: 12px; flex-wrap: wrap;
  }
  .btn {
    background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.15);
    padding:10px 14px; border-radius: 999px; cursor: pointer; backdrop-filter: blur(6px);
    color:#eee;
  }
</style>
</head>
<body>
  <header>Galerie — Consultation uniquement (téléchargement désactivé)</header>

  <main class="grid" id="grid">
    <!-- Mets tes fichiers img1.jpg ... img4.jpg dans le même dossier -->
    <figure class="card">
      <a href="img1.jpg" data-cap="Photo 1">
        <div class="thumb" style="background-image:url('img1.jpg')"></div>
      </a>
      <figcaption class="cap">Photo 1</figcaption>
    </figure>
    <figure class="card">
      <a href="img2.jpg" data-cap="Photo 2">
        <div class="thumb" style="background-image:url('img2.jpg')"></div>
      </a>
      <figcaption class="cap">Photo 2</figcaption>
    </figure>
    <figure class="card">
      <a href="img3.jpg" data-cap="Photo 3">
        <div class="thumb" style="background-image:url('img3.jpg')"></div>
      </a>
      <figcaption class="cap">Photo 3</figcaption>
    </figure>
    <figure class="card">
      <a href="img4.jpg" data-cap="Photo 4">
        <div class="thumb" style="background-image:url('img4.jpg')"></div>
      </a>
      <figcaption class="cap">Photo 4</figcaption>
    </figure>
  </main>

  <!-- Visionneuse zoom/pan -->
  <div class="lightbox" id="box" aria-hidden="true">
    <div class="stage" id="stage" role="dialog" aria-label="Visionneuse">
      <img id="lightImg" alt="Photo zoomable">
    </div>
    <div class="ui">
      <button class="btn" id="prev" aria-label="Précédent">◀</button>
      <button class="btn" id="zoomOut" aria-label="Zoom out">－</button>
      <button class="btn" id="zoomIn" aria-label="Zoom in">＋</button>
      <button class="btn" id="zoomFit" aria-label="Ajuster">Ajuster</button>
      <button class="btn" id="close" aria-label="Fermer">✕ Fermer</button>
      <button class="btn" id="next" aria-label="Suivant">▶</button>
    </div>
  </div>

<script>
(() => {
  const links = Array.from(document.querySelectorAll('#grid a'));
  const box = document.getElementById('box');
  const stage = document.getElementById('stage');
  const img = document.getElementById('lightImg');

  const closeBtn = document.getElementById('close');
  const nextBtn  = document.getElementById('next');
  const prevBtn  = document.getElementById('prev');
  const zoomInBtn  = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');
  const zoomFitBtn = document.getElementById('zoomFit');

  let idx = 0;

  // État zoom/pan
  let scale = 1, minScale = 1, maxScale = 8; // max recalculé à l'ouverture (cover)
  let tx = 0, ty = 0;
  let startX = 0, startY = 0;
  let isPanning = false;
  let moved = false; // pour ne pas fermer sur click après un drag

  // Pointeurs tactiles (pinch)
  const pointers = new Map();
  let startDist = 0, startScale = 1, startMid = {x:0,y:0};
  let imgNatural = {w:0, h:0};

  function loadImageDimensions() {
    return new Promise(res => {
      const tmp = new Image();
      tmp.onload = () => { imgNatural = { w: tmp.naturalWidth, h: tmp.naturalHeight }; res(); };
      tmp.src = img.src;
    });
  }

  function openAt(i){
    idx = (i + links.length) % links.length;
    img.src = links[idx].getAttribute('href');
    img.classList.remove('grabbing');
    img.onload = async () => {
      await loadImageDimensions();
      document.body.classList.add('modal-open');  // bloque le scroll de fond
      box.classList.add('open'); box.setAttribute('aria-hidden', 'false');

      // Calcule FIT (entier à l'écran) et COVER (remplit l'écran)
      const rect = stage.getBoundingClientRect();
      const sw = rect.width, sh = rect.height;
      const fit   = Math.min(sw / imgNatural.w, sh / imgNatural.h);   // affichage demandé au départ
      const cover = Math.max(sw / imgNatural.w, sh / imgNatural.h);   // “zoom max” demandé

      minScale = fit > 0 ? fit : 1;
      maxScale = Math.max(cover, minScale); // zoom max = ancien niveau "trop fort"
      scale = minScale; tx = 0; ty = 0;     // démarrage à la taille écran (contain)
      applyTransform();
    };
  }
  function close(){
    box.classList.remove('open'); box.setAttribute('aria-hidden', 'true');
    document.body.classList.remove('modal-open');
  }

  function applyTransform(){
    img.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px)) scale(${scale})`;
  }

  function zoomAt(pointX, pointY, factor){
    const rect = stage.getBoundingClientRect();
    const newScale = clamp(scale * factor, minScale, maxScale);
    if (Math.abs(newScale - scale) < 1e-6) return;

    // zoom centré autour du pointeur
    const cx = pointX - rect.left - rect.width/2 - tx;
    const cy = pointY - rect.top  - rect.height/2 - ty;
    const k = newScale / scale;

    tx = tx - cx*(k - 1);
    ty = ty - cy*(k - 1);
    scale = newScale;
    applyTransform();
  }

  // Molette : capter et empêcher le scroll
  box.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.2 : 0.8;
    zoomAt(e.clientX, e.clientY, factor);
  }, { passive:false });

  // Souris : pan
  img.addEventListener('mousedown', e => {
    isPanning = true; moved = false; img.classList.add('grabbing');
    startX = e.clientX - tx; startY = e.clientY - ty;
  });
  document.addEventListener('mousemove', e => {
    if(!isPanning) return;
    const ntx = e.clientX - startX;
    const nty = e.clientY - startY;
    if (Math.hypot(ntx - tx, nty - ty) > 2) moved = true;
    tx = ntx; ty = nty;
    applyTransform();
  });
  document.addEventListener('mouseup', () => { isPanning = false; img.classList.remove('grabbing'); });

  // Double-clic : ajuster / zoom x2 depuis le point
  stage.addEventListener('dblclick', e => {
    e.preventDefault();
    if (Math.abs(scale - minScale) < 1e-3) {
      zoomAt(e.clientX, e.clientY, 2);
    } else {
      scale = minScale; tx = 0; ty = 0; applyTransform();
    }
  });

  // Pointer events : pan 1 doigt, pinch 2 doigts
  stage.addEventListener('pointerdown', e => {
    stage.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (pointers.size === 1) {
      isPanning = true; moved = false; startX = e.clientX - tx; startY = e.clientY - ty;
    } else if (pointers.size === 2) {
      const [p1, p2] = [...pointers.values()];
      startDist = dist(p1, p2);
      startScale = scale;
      startMid = mid(p1, p2);
    }
  });
  stage.addEventListener('pointermove', e => {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    if (pointers.size === 1 && isPanning) {
      const ntx = e.clientX - startX;
      const nty = e.clientY - startY;
      if (Math.hypot(ntx - tx, nty - ty) > 2) moved = true;
      tx = ntx; ty = nty; applyTransform();
    } else if (pointers.size === 2) {
      const [p1, p2] = [...pointers.values()];
      const rect = stage.getBoundingClientRect();
      const prevMid = startMid;
      const newMid = mid(p1, p2);

      const ratio = dist(p1, p2) / (startDist || 1);
      const newScale = clamp(startScale * ratio, minScale, maxScale);

      const cx = prevMid.x - rect.left - rect.width/2 - tx;
      const cy = prevMid.y - rect.top  - rect.height/2 - ty;
      const k = newScale / scale || 1;
      tx = tx - cx*(k - 1);
      ty = ty - cy*(k - 1);
      scale = newScale;

      tx += (newMid.x - prevMid.x);
      ty += (newMid.y - prevMid.y);

      startMid = newMid;
      moved = true;
      applyTransform();
    }
  });
  stage.addEventListener('pointerup', e => { pointers.delete(e.pointerId); if (pointers.size===0) isPanning=false; });
  stage.addEventListener('pointercancel', e => { pointers.delete(e.pointerId); if (pointers.size===0) isPanning=false; });

  // Boutons
  zoomInBtn.addEventListener('click', () => {
    const r = stage.getBoundingClientRect();
    zoomAt(r.left + r.width/2, r.top + r.height/2, 1.25);
  });
  zoomOutBtn.addEventListener('click', () => {
    const r = stage.getBoundingClientRect();
    zoomAt(r.left + r.width/2, r.top + r.height/2, 0.8);
  });
  zoomFitBtn.addEventListener('click', () => {
    // retour à "ajusté à l'écran"
    const rect = stage.getBoundingClientRect();
    const fit = Math.min(rect.width / imgNatural.w, rect.height / imgNatural.h) || 1;
    scale = fit; tx = 0; ty = 0; applyTransform();
  });

  // Nav + fermeture
  function openNext(){ openAt(idx+1); }
  function openPrev(){ openAt(idx-1); }
  nextBtn.addEventListener('click', openNext);
  prevBtn.addEventListener('click', openPrev);

  // Fermer seulement si on clique VRAIMENT sur l’arrière-plan (pas la scène)
  box.addEventListener('click', (e) => {
    if (e.target === box && !moved) close();
  });
  closeBtn.addEventListener('click', close);

  // Ouvrir
  links.forEach((a,i) => a.addEventListener('click', e => { e.preventDefault(); openAt(i); }));

  // Dissuasion : clic droit / drag
  document.addEventListener('contextmenu', e => e.preventDefault());
  document.addEventListener('dragstart', e => e.preventDefault());

  // Recalcule fit/cover si on redimensionne pendant l’ouverture
  window.addEventListener('resize', () => {
    if (!box.classList.contains('open')) return;
    const rect = stage.getBoundingClientRect();
    const sw = rect.width, sh = rect.height;
    const fit   = Math.min(sw / imgNatural.w, sh / imgNatural.h);
    const cover = Math.max(sw / imgNatural.w, sh / imgNatural.h);
    minScale = fit > 0 ? fit : 1;
    maxScale = Math.max(cover, minScale);
    // garde la position/zoom en cours mais clamped
    scale = clamp(scale, minScale, maxScale);
    applyTransform();
  });

  // Utils
  function clamp(v, a, b){ return Math.min(Math.max(v, a), b); }
  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function mid(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }
})();
</script>
</body>
</html>





